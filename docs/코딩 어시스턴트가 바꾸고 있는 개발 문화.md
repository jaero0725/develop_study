# 코딩 어시스턴트가 바꾸고 있는 개발 문화 - 2025/04

```
그냥 막하면 잘안됨
교과서에서 나온거는 잘되지만, 레거시 코드를 보고 처리하는건 어렵다.
개인 성과는 높지만, 팀성과가 낮아지는 역설이 생긴다.

2024년에 IQ가 100이하 였찌만
지금은 146 까지 올라왔잇음.

IQ는 시험 잘보는 거에 대한 수치라고 보면된다.
140에 근접한거는 어지간히 물어보면 대답을 잘해준다는 것이다.

제일 높은건 o3, 그다음으로는 제미나이2.5 -> 생각보다 제미나이가 강력하다.

```

```
바이브 코딩에 대한 열풍 분석
- 2025년 2월 안드리에 카파시가 언급
프로그래머가 코드를 직접 작성하는 대신 자연어를 통해 코드를 생성
그저 사물을 보고 말하고 실행하고 복사해서 붙여넣는 방법으로 자연스럽게 흐름을 타면스 프로그래밍하는 기법
- 핵심 부분은 사용자가 코드를 완전히 이해하지 못한 채 코드를 수영 ->
즉 생성형 AI가 만들어준 코드를 검토하고 테스트하는 이해한다면 엄밀히 말해서 바이브 코딩은 아님
=> 바이브 코딩을 하면 안됨
=> 처음부터 만들때 하는것임. 레거시에서는 어려움.

노코드/로코드
누수된 추상화 : 모든 추상화에서 어느지점에서는 분명히 누수되는 구간이 존재하며, 이게 바로 아킬레스 건이됨.
(변수, 함수명을 개떡같이 짜면, 누수되는 지점이 있음 이게 크면 클 수록 도구가 효과가 없음)

다이어그램으로 모든 프로그램을 처리하려는 시도가 대부분 실패한 이유에 대해 생각할 필요가 잇음.
다이어그램으로는 잘되는 것만 잘됨. 잘안되는걸 잘되게 해야됨

개발 단위가 상당히 커지므로, 롤백이나 문제의 정확한 지점을 찾아내기가 어려움
-> 어떻게 잘게 만드는게 중요함. 코드의 단위가 커지기 때문에 통제하기가 어려워짐.
-> 한번에 생각할 수 있는게 적기 때문에 커밋단위가 이전에 작앗는데, 도구를 사용하면서 커지게 됨.

### 주변의 반응
개발 가능한 대표님들과 인터뷰해본 사례 정리
신입 2-3명과 함꼐 일하는 느낌
한동안 코드 작성하지 않다가 다시 해도 많은 부분에서 배울 수 있음.
머리속으로 떠도는 내요을 구체화하기 위해 다른 사람에게 부탁하지 않고 직접 수행할 수 있어 좋음
즉시 대응
하지만 전사적으로 개발 문화를 어떻게 구축할지에 대해서 고민이 많음.
=> 어떻게 전사적으로 개발 문화를 구축할지에 대해서 고민이라는게 이슈
```


### 코딩 어시스턴트 유형과 LLm이 미치는 영향

```
섞어 써야됨 !

문제에 대해서 분석 연구할때는 -> o3
코드를 만들때는 -> 제미나이

프로그램 작성 과정에서 전체 코드 베이스가 아닌 일부 코드 베이스를 작성해달라고 요청하거나 문제가 되거나 확장이 필욯ㄴ 코드베이스를 보여주고 지시를 내리는 방식
요즘 나오는 chat gpt는 터미널과 상호 작용이 가능하도록 되어 있어 한결 편리해짐 하지만 좀 불편함.  

중요한건 생각하고 평가하는 시간을 인위적으로 만들어줘야된다.

# CLI 활용
보안 문제 관련해서 ->> 라이브러리에 대한 보안문제 있는거 이런걸 처리
배치성으로 왕창 돌리때 좋음
아마존 큐? - 아마존에 있는 클라우드에 도움이 잘됨. 잘해줌.

* default llm보다는 돈쓰는게 좋음.
* OpeanAI Codex : 심지어 코드까지 개방되어 있음. - 회사용으로 전용으로 만들 수 잇음, Claude Code 최신버전이 좀 안좋다는 얘기가 있긴함.(250421)

# 통합 개발 환경
MCP를 지원하기 시작했으므로, 외부 서비스까지 연계 해서 동작이 가능해짐.
* MCP알려주지 않은거 다운 받지말기 - 보안문제
요즘에 git Conflict까지 비교해서 처리해줌
커서/윈드서퍼/제미나이 코드

# 어떤 LLM이 좋을까?
- Thinking모드가 있는게 좋음.
- 버짓이 있어서 제미나이 2.5는 생각하는 시간도 줄일 수 있어서 좋은듯?
- 6개월마다 업데이트 가 되는 경우가 많으니깐, 참고 
```

### UI 코딩 vs 백엔드 코딩
- 코딩 어시스턴트는 대부분 UI코딩에 강함
  1) UI는 직접 눈에 보이므로 명시적으로 수정대상을 지정하기 쉬움
- 백엔드 코딩의 함정
  1) 백엔드는 비지니스 로직이 녹아들어 있기 때문에 대부분 외부에 공개되지 않음
  2) LLm이 목격한 적이 없음
  3) 문서와 데이터가 절대적으로 부족한 상황임
  4) 단순 CRUD API서빙을 굉장히 잘한다.
  5) 데이터베이스 스키마 부터 시작해서 API서버
  6) 레거시 과 연동이 많을 경우 사실상 코드 작성이 매우 어려워짐
  7) Swagger를 만들고 API시키면 좋음. JSON파싱기능은 요즘엔 엄청잘해줌.

 ### 학습 목적 vs 지원 목적
 - 새로운 기술을 배울때 역량 강화
   1) 수직 시장에서 도메인도 알고 있으며 프로그램도 잘아는 LLM을 사용해야할 필요가 잇음
   2) 의료쪽은 제미나이를 사용해야 제대로된 된 결과가 나옴.
   3) 너무 새로운 프레임워크나 인지도가 떨어지는 프레임워크 라이브러리르 학습하는 경우라면 LLM이 환각을 크게 일으킬 가능성이 있음. (최신라이브러리는 LLm사용하지말자 그냥, 아니면 물어보고 시작해보자.)
- 인턴 직원으로서 코딩 어시스턴트(생산성 강화)
  1) 기존 코드베이스와 무관하게 빠르게 PoC를 하는 경우라면 코딩 어시스턴트가 위력을 발휘함.
- 코드 리뷰어로서 코딩 어시스턴트
  1) 어떤 리뷰를 받고 싶은지 결정할 필요가 있음. (아마존 Q와 같은 서비스는 보안 쪽에 강점을 보인다)
  2) 코등관례를 넘어서 클린코드와 같은 규칙을 준수하고 있는지 확인할 수 있음.
  3) 코딩컨벤션이나 함수명명, 변수명 등 추가로 클린코드처리 .cursor에 넣어주자. -> 팀에서 결정할거임.
  4) 도메인 관점에서 제약이 있는걸 생각해봐야됨. 성능관련 내용은 잘알려준다. - 페르소나를 주고 코드의 견고함을 줄 수 있음

### 코딩 어시스턴트의 약점

```
1. 최신 라이브러리 사용시

Spring은 진짜 잘한다.
1.0을 찍지 못한 프레임워크나 라이브러리인 경우에는 상당한 혼란을 일으킬 가능성에 대해 고민해야함.

2. 문서화가 덜된 오픈소스 라이브러리 사용시
javadocs, JsDOc과 같은 표준적인 방식으로 코드 내부에 문서화가 되어 있는 경우라면 LLM이 상당히 정확하게 학습했을 가능성인 높음
- LLM이 노예다. 문서화를 잘해야되는 이유는 LLM이 문서를 보기 때문이다.
- 영어로 지시하는게 좋을 가능성이 높다. 웹에 연계 하는 경우가 많으므로 이상한 블로그 읽는 경우가 많음. 그래서 영어로 질문해라.
- 영어로 하면 참조하는 데이터가 달라진다. 잘못가져오는 경우가 많다. 어쩔수없다. 영어로해라

3. 교과서에 실리지 않은 특이한 도메인이나 알고리즘
- LLM은 처음에 프로그래밍 언어를 익히고 다음에 알고리즘과 자료 구조를 익히도록 진행되는 경우가 많음 -> 이유 :추론 논리력 향상
- 교과서에 나온내용은 정말 정확하게 칼같이 표준적인 방식으로 구현함
- 특히 우려하는 바는 외부의 표준적인 보안 라이브러리를  사용하지 않고 직접 구현한 보안 라이브러리가 코드베이스에 있는 경우인데, 만의 하나롣 LLm이 이에 개입하면 후폭풍이 매우 클것이다.
- 주석으로 손대지말라고 하면 완하시켜서 안 건드릴수 있음 -> 주석은 사람을 위해서 쓰는게 아니라 LLM을 위해 쓴다.

4. 개발/실행 환경에 무지
- 맥락읠 알려주지 않는 이상 파악하려고 노력하지 않음.
- 개발/스테이징/실행환경이 어떻게 구성되어 있는지 하드웨어상으로 어떤 제약이 있는지에 대해서 알려주지 않는 이상 관심 없음.
- "맥락을 많이줘야한다."

5. MCP등 사용시 보안문제
* Tool Poisiong 공격
- 사용자에게는 보이지 않지만 AI모델에는 보이는 MCP도구 설명에 포함될 떄 발생함.

6. 코드 베이스 구모에 따른 토큰 비용 상승
- BYOL - 키를 입력해서 쓸 수 잇음.
- 파일단위가 아니고 압축해서 보낸다. 
- 비용통제에 대해서 민감해줘야 된다. 정액제는 성능이 좋지 않음.

```
### 프로젝트 유형별 전략
#### Green field
- 예시 PoC와 프로토타입 구현

#### Brown field
- 예시 기존 코드 기능 추가 확장 변경 버전 이식
- 버전 잇기의 경우 짭짤한 재미를 볼 수 잇음
- 기능 추가의 경우에는 레거시 연동이 관건임.
- 코드 문서에 넣어준다.
- JavaDoc를 넣어주자.

#### Legacy field
- dry run으로 레거시 코드 분석 작업부터 진행해서 코딩 어시스턴트

" 모르는지 아는지에 대해서 판단시킨다. 분석을 시킨다. "
"이 코드에 대해서 리팩토링할 계획을 만들어서 제안을 줘. 코드를 보여주지마."

-> 자세하게 알려준다. 
-> 엣날걸 까먹는 경우가 많음. long context는 

최상단에 한줄
최하단에 한줄

커밋을 명령당단위한다.

#### 프롬포트 예제
```
시스템디자인모드
"아직 코드 만들지마"

가정확인
"가정에 대해서 모두 나열해봐"
-> 틀린거 지적
"이상한것들 물어봐봐 나한테 모호한걸 물어봐"

검증루프
"오해가 일어날 가능성이 있는걸 보여주고 검증해줘"

실행모드 (조향)
"주석좁 달아줘. 내가 편집하기 쉽게 해줘. 클린코드 원칙에 의거해서 잘 짜줘."
- 방향전환할때 가이드를 해야됨. 
```

#### 참고 생성형 AI가 미치는 코드 품질 관련
```
  중복이 많다. 
  코드 일관성이 없어짐. 
  완전히 산으로 갈 수 있음
  
  코드 품질의 악화가 가속화되고 있다는 여러 신호 발견
  복붙한 줄의 빈도가 예측보다 6% 더 빠르게 증가 
  리팩토링의 증거인 코드 이동 줄 수가 급격하게 감소

  좋은사례: 에어비엔비 테스트 마이그레이션
```

  
   
  
